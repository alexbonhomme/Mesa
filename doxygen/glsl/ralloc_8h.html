<html>
<head>
<title>Mesa Source Code Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="qindex">
<a class="qindex" href="../main/index.html">core</a> |
<a class="qindex" href="../glapi/index.html">glapi</a> |
<a class="qindex" href="../glsl/index.html">glsl</a> |
<a class="qindex" href="../vbo/index.html">vbo</a> |
<a class="qindex" href="../math/index.html">math</a> |
<a class="qindex" href="../shader/index.html">shader</a> |
<a class="qindex" href="../swrast/index.html">swrast</a> |
<a class="qindex" href="../swrast_setup/index.html">swrast_setup</a> |
<a class="qindex" href="../tnl/index.html">tnl</a> |
<a class="qindex" href="../tnl_dd/index.html">tnl_dd</a> |
<a class="qindex" href="../gbm/index.html">gbm</a>
</div>
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_9d873dbfec6053c8a46a8bdca18df976.html">glsl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ralloc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ralloc: a recursive memory allocator  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>
<code>#include &lt;stdbool.h&gt;</code><br/>
<code>#include &quot;main/compiler.h&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ralloc.h:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h__incl.png" border="0" usemap="#ralloc_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h__dep__incl.png" border="0" usemap="#ralloc_8hdep" alt=""/></div>
<map name="ralloc_8hdep" id="ralloc_8hdep">
<area shape="rect" id="node3" href="list_8h.html" title="Doubly&#45;linked list abstract container type." alt="" coords="233,80,284,107"/><area shape="rect" id="node13" href="glsl__parser__extras_8cpp.html" title="glsl_parser_extras.cpp" alt="" coords="5,328,157,355"/><area shape="rect" id="node17" href="ir_8h.html" title="ir.h" alt="" coords="2903,155,2943,181"/><area shape="rect" id="node119" href="ralloc_8c.html" title="ralloc.c" alt="" coords="359,80,423,107"/><area shape="rect" id="node121" href="standalone__scaffolding_8cpp.html" title="standalone_scaffolding.cpp" alt="" coords="447,80,627,107"/><area shape="rect" id="node5" href="ast_8h.html" title="ast.h" alt="" coords="233,155,284,181"/><area shape="rect" id="node115" href="s__expression_8h.html" title="s_expression.h" alt="" coords="98,155,208,181"/><area shape="rect" id="node7" href="ast__array__index_8cpp.html" title="ast_array_index.cpp" alt="" coords="220,237,359,264"/><area shape="rect" id="node9" href="ast__function_8cpp.html" title="ast_function.cpp" alt="" coords="1838,328,1956,355"/><area shape="rect" id="node11" href="ast__to__hir_8cpp.html" title="ast_to_hir.cpp" alt="" coords="656,328,760,355"/><area shape="rect" id="node15" href="hir__field__selection_8cpp.html" title="hir_field_selection.cpp" alt="" coords="383,237,533,264"/><area shape="rect" id="node20" href="glsl__symbol__table_8h.html" title="glsl_symbol_table.h" alt="" coords="2801,237,2937,264"/><area shape="rect" id="node24" href="builtin__variables_8cpp.html" title="builtin_variables.cpp" alt="" coords="2161,328,2300,355"/><area shape="rect" id="node26" href="ir__import__prototypes_8cpp.html" title="Import function prototypes from one IR tree into another." alt="" coords="2325,328,2491,355"/><area shape="rect" id="node28" href="link__functions_8cpp.html" title="link_functions.cpp" alt="" coords="2515,328,2641,355"/><area shape="rect" id="node30" href="link__interface__blocks_8cpp.html" title="Linker support for GLSL&#39;s interface blocks." alt="" coords="2666,328,2835,355"/><area shape="rect" id="node32" href="link__uniform__initializers_8cpp.html" title="link_uniform_initializers.cpp" alt="" coords="2859,328,3041,355"/><area shape="rect" id="node34" href="link__uniforms_8cpp.html" title="Assign locations for GLSL uniforms." alt="" coords="3066,328,3189,355"/><area shape="rect" id="node36" href="linker_8cpp.html" title="GLSL linker implementation." alt="" coords="3214,328,3292,355"/><area shape="rect" id="node38" href="lower__clip__distance_8cpp.html" title="This pass accounts for the difference between the way gl_ClipDistance is declared in standard GLSL (a..." alt="" coords="3317,328,3477,355"/><area shape="rect" id="node40" href="lower__named__interface__blocks_8cpp.html" title="This lowering pass converts all interface blocks with instance names into interface blocks without an..." alt="" coords="1981,321,2136,362"/><area shape="rect" id="node44" href="ir__reader_8h.html" title="ir_reader.h" alt="" coords="3853,237,3936,264"/><area shape="rect" id="node47" href="loop__analysis_8h.html" title="loop_analysis.h" alt="" coords="559,237,671,264"/><area shape="rect" id="node51" href="ir_8cpp.html" title="ir.cpp" alt="" coords="3961,237,4015,264"/><area shape="rect" id="node53" href="ir__basic__block_8cpp.html" title="Basic block analysis of instruction streams." alt="" coords="4040,237,4171,264"/><area shape="rect" id="node55" href="ir__builder_8h.html" title="ir_builder.h" alt="" coords="3693,237,3779,264"/><area shape="rect" id="node57" href="lower__instructions_8cpp.html" title="Many GPUs lack native instructions for certain expression operations, and must replace them with some..." alt="" coords="3873,328,4025,355"/><area shape="rect" id="node59" href="ir__clone_8cpp.html" title="ir_clone.cpp" alt="" coords="4195,237,4287,264"/><area shape="rect" id="node61" href="ir__constant__expression_8cpp.html" title="Evaluate and process constant valued expressions." alt="" coords="4501,237,4683,264"/><area shape="rect" id="node63" href="ir__expression__flattening_8cpp.html" title="Takes the leaves of expression trees and makes them dereferences of assignments of the leaves to temp..." alt="" coords="4707,237,4891,264"/><area shape="rect" id="node65" href="ir__function_8cpp.html" title="ir_function.cpp" alt="" coords="4915,237,5021,264"/><area shape="rect" id="node67" href="ir__function__can__inline_8cpp.html" title="Determines if we can inline a function call using ir_function_inlining.cpp." alt="" coords="5046,237,5217,264"/><area shape="rect" id="node69" href="ir__function__detect__recursion_8cpp.html" title="Determine whether a shader contains static recursion." alt="" coords="745,230,871,271"/><area shape="rect" id="node71" href="ir__hierarchical__visitor_8cpp.html" title="ir_hierarchical_visitor.cpp" alt="" coords="895,237,1064,264"/><area shape="rect" id="node73" href="ir__hv__accept_8cpp.html" title="Implementations of all hierarchical visitor accept methods for IR instructions." alt="" coords="1089,237,1209,264"/><area shape="rect" id="node76" href="ir__print__visitor_8h.html" title="ir_print_visitor.h" alt="" coords="4363,237,4477,264"/><area shape="rect" id="node78" href="ir__rvalue__visitor_8cpp.html" title="Generic class to implement the common pattern we have of wanting to visit each ir_rvalue * and possib..." alt="" coords="4303,328,4441,355"/><area shape="rect" id="node81" href="ir__set__program__inouts_8cpp.html" title="Sets the InputsRead and OutputsWritten of Mesa programs." alt="" coords="1234,237,1408,264"/><area shape="rect" id="node83" href="ir__validate_8cpp.html" title="Attempts to verify that various invariants of the IR tree are true." alt="" coords="1433,237,1540,264"/><area shape="rect" id="node85" href="ir__variable__refcount_8cpp.html" title="Provides a visitor which produces a list of variables referenced, how many times they were referenced..." alt="" coords="3503,328,3663,355"/><area shape="rect" id="node87" href="ir__variable__refcount_8h.html" title="Provides a visitor which produces a list of variables referenced, how many times they were referenced..." alt="" coords="3317,237,3464,264"/><area shape="rect" id="node92" href="link__uniform__block__active__visitor_8h.html" title="link_uniform_block\l_active_visitor.h" alt="" coords="3488,230,3619,271"/><area shape="rect" id="node94" href="link__uniform__blocks_8cpp.html" title="link_uniform_blocks.cpp" alt="" coords="3687,328,3849,355"/><area shape="rect" id="node101" href="lower__discard_8cpp.html" title="This pass moves discards out of if&#45;statements." alt="" coords="1565,237,1691,264"/><area shape="rect" id="node103" href="lower__discard__flow_8cpp.html" title="Implements the GLSL 1.30 revision 9 rule for fragment shader discard handling:" alt="" coords="1715,237,1873,264"/><area shape="rect" id="node105" href="lower__if__to__cond__assign_8cpp.html" title="This attempts to flatten if&#45;statements to conditional assignments for GPUs with limited or no flow co..." alt="" coords="1898,237,2088,264"/><area shape="rect" id="node108" href="lower__jumps_8cpp.html" title="This pass lowers jumps (break, continue, and return) to if/else structures." alt="" coords="2113,237,2233,264"/><area shape="rect" id="node110" href="lower__mat__op__to__vec_8cpp.html" title="Breaks matrix operation expressions down to a series of vector operations." alt="" coords="2258,237,2432,264"/><area shape="rect" id="node113" href="lower__noise_8cpp.html" title="IR lower pass to remove noise opcodes." alt="" coords="2457,237,2572,264"/></map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab63ba8a1072be4cbcea95c140697dcf1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#ab63ba8a1072be4cbcea95c140697dcf1">ralloc</a>(ctx, type)&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#a03d668aa9fce8d82182c2bfbd3f2a4e3">ralloc_size</a>(ctx, sizeof(type)))</td></tr>
<tr class="memdesc:ab63ba8a1072be4cbcea95c140697dcf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new object chained off of the given context.  <a href="#ab63ba8a1072be4cbcea95c140697dcf1">More...</a><br/></td></tr>
<tr class="separator:ab63ba8a1072be4cbcea95c140697dcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a338325a439c2d9b513de889053aa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#ad8a338325a439c2d9b513de889053aa3">rzalloc</a>(ctx, type)&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#a04d6d49f08bc3721b2c5dd1faac23a1c">rzalloc_size</a>(ctx, sizeof(type)))</td></tr>
<tr class="memdesc:ad8a338325a439c2d9b513de889053aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new object out of the given context and initialize it to zero.  <a href="#ad8a338325a439c2d9b513de889053aa3">More...</a><br/></td></tr>
<tr class="separator:ad8a338325a439c2d9b513de889053aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6818ee56f93509fc276427b91dae6cc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a6818ee56f93509fc276427b91dae6cc2">ralloc_array</a>(ctx, type, count)&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#a013e8df0993ef0373cfa7cde6c302d53">ralloc_array_size</a>(ctx, sizeof(type), count))</td></tr>
<tr class="memdesc:a6818ee56f93509fc276427b91dae6cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an array of objects chained off the given context.  <a href="#a6818ee56f93509fc276427b91dae6cc2">More...</a><br/></td></tr>
<tr class="separator:a6818ee56f93509fc276427b91dae6cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27f97db91b041ad60bcf6a7ff663156"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#af27f97db91b041ad60bcf6a7ff663156">rzalloc_array</a>(ctx, type, count)&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#a12c3f10245853c0bde6883e5365e4012">rzalloc_array_size</a>(ctx, sizeof(type), count))</td></tr>
<tr class="memdesc:af27f97db91b041ad60bcf6a7ff663156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a zero-initialized array chained off the given context.  <a href="#af27f97db91b041ad60bcf6a7ff663156">More...</a><br/></td></tr>
<tr class="separator:af27f97db91b041ad60bcf6a7ff663156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d63d792e98e69b4b8364008e8edb4bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a9d63d792e98e69b4b8364008e8edb4bb">reralloc</a>(ctx, ptr, type, count)&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#af37fae09221c71687f0cc2295d6b163f">reralloc_array_size</a>(ctx, ptr, sizeof(type), count))</td></tr>
<tr class="memdesc:a9d63d792e98e69b4b8364008e8edb4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a ralloc-managed array, preserving data.  <a href="#a9d63d792e98e69b4b8364008e8edb4bb">More...</a><br/></td></tr>
<tr class="separator:a9d63d792e98e69b4b8364008e8edb4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a38530c9f4ef437290b8acd706b858410"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a38530c9f4ef437290b8acd706b858410">ralloc_context</a> (const void *ctx)</td></tr>
<tr class="memdesc:a38530c9f4ef437290b8acd706b858410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new ralloc context.  <a href="#a38530c9f4ef437290b8acd706b858410">More...</a><br/></td></tr>
<tr class="separator:a38530c9f4ef437290b8acd706b858410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d668aa9fce8d82182c2bfbd3f2a4e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a03d668aa9fce8d82182c2bfbd3f2a4e3">ralloc_size</a> (const void *ctx, size_t size)</td></tr>
<tr class="memdesc:a03d668aa9fce8d82182c2bfbd3f2a4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory chained off of the given context.  <a href="#a03d668aa9fce8d82182c2bfbd3f2a4e3">More...</a><br/></td></tr>
<tr class="separator:a03d668aa9fce8d82182c2bfbd3f2a4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d6d49f08bc3721b2c5dd1faac23a1c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a04d6d49f08bc3721b2c5dd1faac23a1c">rzalloc_size</a> (const void *ctx, size_t size)</td></tr>
<tr class="memdesc:a04d6d49f08bc3721b2c5dd1faac23a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate zero-initialized memory chained off of the given context.  <a href="#a04d6d49f08bc3721b2c5dd1faac23a1c">More...</a><br/></td></tr>
<tr class="separator:a04d6d49f08bc3721b2c5dd1faac23a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1adf0ae73bf982e8aceff21b47959c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a3a1adf0ae73bf982e8aceff21b47959c">reralloc_size</a> (const void *ctx, void *ptr, size_t size)</td></tr>
<tr class="memdesc:a3a1adf0ae73bf982e8aceff21b47959c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a piece of ralloc-managed memory, preserving data.  <a href="#a3a1adf0ae73bf982e8aceff21b47959c">More...</a><br/></td></tr>
<tr class="separator:a3a1adf0ae73bf982e8aceff21b47959c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013e8df0993ef0373cfa7cde6c302d53"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a013e8df0993ef0373cfa7cde6c302d53">ralloc_array_size</a> (const void *ctx, size_t size, unsigned count)</td></tr>
<tr class="memdesc:a013e8df0993ef0373cfa7cde6c302d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for an array chained off the given context.  <a href="#a013e8df0993ef0373cfa7cde6c302d53">More...</a><br/></td></tr>
<tr class="separator:a013e8df0993ef0373cfa7cde6c302d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c3f10245853c0bde6883e5365e4012"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a12c3f10245853c0bde6883e5365e4012">rzalloc_array_size</a> (const void *ctx, size_t size, unsigned count)</td></tr>
<tr class="memdesc:a12c3f10245853c0bde6883e5365e4012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a zero-initialized array chained off the given context.  <a href="#a12c3f10245853c0bde6883e5365e4012">More...</a><br/></td></tr>
<tr class="separator:a12c3f10245853c0bde6883e5365e4012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37fae09221c71687f0cc2295d6b163f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#af37fae09221c71687f0cc2295d6b163f">reralloc_array_size</a> (const void *ctx, void *ptr, size_t size, unsigned count)</td></tr>
<tr class="memdesc:af37fae09221c71687f0cc2295d6b163f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a ralloc-managed array, preserving data.  <a href="#af37fae09221c71687f0cc2295d6b163f">More...</a><br/></td></tr>
<tr class="separator:af37fae09221c71687f0cc2295d6b163f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280f5ecb6525a10e479c0b7c4ff89690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a280f5ecb6525a10e479c0b7c4ff89690">ralloc_free</a> (void *ptr)</td></tr>
<tr class="memdesc:a280f5ecb6525a10e479c0b7c4ff89690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a piece of ralloc-managed memory.  <a href="#a280f5ecb6525a10e479c0b7c4ff89690">More...</a><br/></td></tr>
<tr class="separator:a280f5ecb6525a10e479c0b7c4ff89690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5d6cd015f1bb09e1ffc6413ab4a326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a8a5d6cd015f1bb09e1ffc6413ab4a326">ralloc_steal</a> (const void *new_ctx, void *ptr)</td></tr>
<tr class="memdesc:a8a5d6cd015f1bb09e1ffc6413ab4a326"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Steal" memory from one context, changing it to another.  <a href="#a8a5d6cd015f1bb09e1ffc6413ab4a326">More...</a><br/></td></tr>
<tr class="separator:a8a5d6cd015f1bb09e1ffc6413ab4a326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f820b482c39fab77bf884a420aeb4f2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a9f820b482c39fab77bf884a420aeb4f2">ralloc_parent</a> (const void *ptr)</td></tr>
<tr class="memdesc:a9f820b482c39fab77bf884a420aeb4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given pointer's ralloc context.  <a href="#a9f820b482c39fab77bf884a420aeb4f2">More...</a><br/></td></tr>
<tr class="separator:a9f820b482c39fab77bf884a420aeb4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0178b0bdc429496e03dc3682cfdb25cb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a0178b0bdc429496e03dc3682cfdb25cb">ralloc_autofree_context</a> (void)</td></tr>
<tr class="memdesc:a0178b0bdc429496e03dc3682cfdb25cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a context whose memory will be automatically freed at program exit.  <a href="#a0178b0bdc429496e03dc3682cfdb25cb">More...</a><br/></td></tr>
<tr class="separator:a0178b0bdc429496e03dc3682cfdb25cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90aa1c7c5d666c1a09aca7450d9edad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#aa90aa1c7c5d666c1a09aca7450d9edad">ralloc_set_destructor</a> (const void *ptr, void(*destructor)(void *))</td></tr>
<tr class="memdesc:aa90aa1c7c5d666c1a09aca7450d9edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback to occur just before an object is freed.  <a href="#aa90aa1c7c5d666c1a09aca7450d9edad">More...</a><br/></td></tr>
<tr class="separator:aa90aa1c7c5d666c1a09aca7450d9edad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0565a6a6f82e3ca9fbae2ede2ee8ac39"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a0565a6a6f82e3ca9fbae2ede2ee8ac39">ralloc_strdup</a> (const void *ctx, const char *str)</td></tr>
<tr class="memdesc:a0565a6a6f82e3ca9fbae2ede2ee8ac39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a string, allocating the memory from the given context.  <a href="#a0565a6a6f82e3ca9fbae2ede2ee8ac39">More...</a><br/></td></tr>
<tr class="separator:a0565a6a6f82e3ca9fbae2ede2ee8ac39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac413d04bbe87e8d99ab60fa0abe375da"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#ac413d04bbe87e8d99ab60fa0abe375da">ralloc_strndup</a> (const void *ctx, const char *str, size_t n)</td></tr>
<tr class="memdesc:ac413d04bbe87e8d99ab60fa0abe375da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a string, allocating the memory from the given context.  <a href="#ac413d04bbe87e8d99ab60fa0abe375da">More...</a><br/></td></tr>
<tr class="separator:ac413d04bbe87e8d99ab60fa0abe375da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81efd739143e83e06e3f6b3da7f943bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a81efd739143e83e06e3f6b3da7f943bf">ralloc_strcat</a> (char **dest, const char *str)</td></tr>
<tr class="memdesc:a81efd739143e83e06e3f6b3da7f943bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two strings, allocating the necessary space.  <a href="#a81efd739143e83e06e3f6b3da7f943bf">More...</a><br/></td></tr>
<tr class="separator:a81efd739143e83e06e3f6b3da7f943bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d8ab2458cbde4f99e35c36e1c6cc11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a76d8ab2458cbde4f99e35c36e1c6cc11">ralloc_strncat</a> (char **dest, const char *str, size_t n)</td></tr>
<tr class="memdesc:a76d8ab2458cbde4f99e35c36e1c6cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two strings, allocating the necessary space.  <a href="#a76d8ab2458cbde4f99e35c36e1c6cc11">More...</a><br/></td></tr>
<tr class="separator:a76d8ab2458cbde4f99e35c36e1c6cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc315b946d7bdb33ef44c4b991174ea"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#aedc315b946d7bdb33ef44c4b991174ea">ralloc_asprintf</a> (const void *ctx, const char *fmt,...) PRINTFLIKE(2</td></tr>
<tr class="memdesc:aedc315b946d7bdb33ef44c4b991174ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print to a string.  <a href="#aedc315b946d7bdb33ef44c4b991174ea">More...</a><br/></td></tr>
<tr class="separator:aedc315b946d7bdb33ef44c4b991174ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75be6b63118900b80715f9cd472a984"><td class="memItemLeft" align="right" valign="top">char char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#ac75be6b63118900b80715f9cd472a984">ralloc_vasprintf</a> (const void *ctx, const char *fmt, va_list args)</td></tr>
<tr class="memdesc:ac75be6b63118900b80715f9cd472a984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print to a string, given a va_list.  <a href="#ac75be6b63118900b80715f9cd472a984">More...</a><br/></td></tr>
<tr class="separator:ac75be6b63118900b80715f9cd472a984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2980b62e5f650ff720d26793c905c9df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a2980b62e5f650ff720d26793c905c9df">ralloc_asprintf_rewrite_tail</a> (char **str, size_t *start, const char *fmt,...) PRINTFLIKE(3</td></tr>
<tr class="memdesc:a2980b62e5f650ff720d26793c905c9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the tail of an existing string, starting at a given index.  <a href="#a2980b62e5f650ff720d26793c905c9df">More...</a><br/></td></tr>
<tr class="separator:a2980b62e5f650ff720d26793c905c9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba98d7ec76e48fe68428e87099631b5"><td class="memItemLeft" align="right" valign="top">bool bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a8ba98d7ec76e48fe68428e87099631b5">ralloc_vasprintf_rewrite_tail</a> (char **str, size_t *start, const char *fmt, va_list args)</td></tr>
<tr class="memdesc:a8ba98d7ec76e48fe68428e87099631b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the tail of an existing string, starting at a given index.  <a href="#a8ba98d7ec76e48fe68428e87099631b5">More...</a><br/></td></tr>
<tr class="separator:a8ba98d7ec76e48fe68428e87099631b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfca8fae6b0d1aab2a83d3ce993b9a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#abbfca8fae6b0d1aab2a83d3ce993b9a6">ralloc_asprintf_append</a> (char **str, const char *fmt,...) PRINTFLIKE(2</td></tr>
<tr class="memdesc:abbfca8fae6b0d1aab2a83d3ce993b9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append formatted text to the supplied string.  <a href="#abbfca8fae6b0d1aab2a83d3ce993b9a6">More...</a><br/></td></tr>
<tr class="separator:abbfca8fae6b0d1aab2a83d3ce993b9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414ae58d2f6a0cb6e04b3bf71d3193da"><td class="memItemLeft" align="right" valign="top">bool bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ralloc_8h.html#a414ae58d2f6a0cb6e04b3bf71d3193da">ralloc_vasprintf_append</a> (char **str, const char *fmt, va_list args)</td></tr>
<tr class="memdesc:a414ae58d2f6a0cb6e04b3bf71d3193da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append formatted text to the supplied string, given a va_list.  <a href="#a414ae58d2f6a0cb6e04b3bf71d3193da">More...</a><br/></td></tr>
<tr class="separator:a414ae58d2f6a0cb6e04b3bf71d3193da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ralloc: a recursive memory allocator </p>
<p>The ralloc memory allocator creates a hierarchy of allocated objects. Every allocation is in reference to some parent, and every allocated object can in turn be used as the parent of a subsequent allocation. This allows for extremely convenient discarding of an entire tree/sub-tree of allocations by calling ralloc_free on any particular object to free it and all of its children.</p>
<p>The conceptual working of ralloc was directly inspired by Andrew Tridgell's talloc, but ralloc is an independent implementation released under the MIT license and tuned for Mesa.</p>
<p>The talloc implementation is available under the GNU Lesser General Public License (GNU LGPL), version 3 or later. It is more sophisticated than ralloc in that it includes reference counting and debugging features. See: <a href="http://talloc.samba.org/">http://talloc.samba.org/</a> </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ab63ba8a1072be4cbcea95c140697dcf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ralloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ctx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#a03d668aa9fce8d82182c2bfbd3f2a4e3">ralloc_size</a>(ctx, sizeof(type)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new object chained off of the given context. </p>
<p>This is equivalent to: </p>
<div class="fragment"><div class="line">((type *) <a class="code" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context.">ralloc_size</a>(ctx, <span class="keyword">sizeof</span>(type))</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6818ee56f93509fc276427b91dae6cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ralloc_array</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ctx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#a013e8df0993ef0373cfa7cde6c302d53">ralloc_array_size</a>(ctx, sizeof(type), count))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an array of objects chained off the given context. </p>
<p>Similar to <code>calloc</code>, but does not initialize the memory to zero.</p>
<p>More than a convenience function, this also checks for integer overflow when multiplying <code>sizeof(type)</code> and <code>count</code>. This is necessary for security.</p>
<p>This is equivalent to: </p>
<div class="fragment"><div class="line">((type *) <a class="code" href="ralloc_8c.html#a013e8df0993ef0373cfa7cde6c302d53" title="Allocate memory for an array chained off the given context.">ralloc_array_size</a>(ctx, <span class="keyword">sizeof</span>(type), count)</div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="builtin__variables_8cpp.html#a340bb566cdd78f7491c7254aef47b194">add_uniform()</a>, <a class="el" href="ast__to__hir_8cpp.html#ac702c95b56d05a00fe259d9fae646e6f">ast_process_structure_or_interface_block()</a>, <a class="el" href="classir__variable.html#a7e051d333749b712caf01a880b1ea767">ir_variable::clone()</a>, <a class="el" href="classir__constant.html#a87070a45c2509f35c49c4e33de4735f5">ir_constant::clone()</a>, <a class="el" href="opt__structure__splitting_8cpp.html#a613d55aa3cfd58ddeadcb5bfaa92e46a">do_structure_splitting()</a>, <a class="el" href="linker_8cpp.html#ae55bc18ea8ee02a56b7608b8e0f49a29">interstage_cross_validate_uniform_blocks()</a>, <a class="el" href="classir__constant.html#aacb27d8fa7a4c51b58080f7104769379">ir_constant::ir_constant()</a>, <a class="el" href="linker_8h.html#ac24e5d2a63f74e49dfd25f72e9275da3">link_cross_validate_uniform_block()</a>, <a class="el" href="program_8h.html#afc0379dac600d4977ea2e7ae44096f1a">link_shaders()</a>, <a class="el" href="linker_8h.html#aef3e3e62d7cadff0e6d9b295965137f1">link_uniform_blocks()</a>, <a class="el" href="opt__array__splitting_8cpp.html#a9afe02479db22138e42085ec00a32685">optimize_split_arrays()</a>, <a class="el" href="ralloc_8h.html#a0565a6a6f82e3ca9fbae2ede2ee8ac39">ralloc_strdup()</a>, <a class="el" href="ralloc_8h.html#ac413d04bbe87e8d99ab60fa0abe375da">ralloc_strndup()</a>, and <a class="el" href="classir__constant.html#a100b81bbadd29f5dda887eae5fa3d01a">ir_constant::zero()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d63d792e98e69b4b8364008e8edb4bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define reralloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ctx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#af37fae09221c71687f0cc2295d6b163f">reralloc_array_size</a>(ctx, ptr, sizeof(type), count))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a ralloc-managed array, preserving data. </p>
<p>Similar to <code>realloc</code>. Unlike C89, passing 0 for <code>size</code> does not free the memory. Instead, it resizes it to a 0-byte ralloc context, just like calling ralloc_size(ctx, 0). This is different from talloc.</p>
<p>More than a convenience function, this also checks for integer overflow when multiplying <code>sizeof(type)</code> and <code>count</code>. This is necessary for security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context to use for new allocation. If <code>ptr</code> != NULL, it must be the same as ralloc_parent(<code>ptr</code>). </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the array to be resized. May be NULL. </td></tr>
    <tr><td class="paramname">type</td><td>The element type. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to allocate. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classast__struct__specifier.html#ab4597851b0e517214b5f44fb363cd4a3">ast_struct_specifier::hir()</a>, <a class="el" href="linker_8h.html#ac24e5d2a63f74e49dfd25f72e9275da3">link_cross_validate_uniform_block()</a>, <a class="el" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="classlink__uniform__block__active__visitor.html#a0762535affea3f3226169e3536a568b4">link_uniform_block_active_visitor::visit_enter()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8a338325a439c2d9b513de889053aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rzalloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ctx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#a04d6d49f08bc3721b2c5dd1faac23a1c">rzalloc_size</a>(ctx, sizeof(type)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new object out of the given context and initialize it to zero. </p>
<p>This is equivalent to: </p>
<div class="fragment"><div class="line">((type *) <a class="code" href="ralloc_8c.html#a04d6d49f08bc3721b2c5dd1faac23a1c" title="Allocate zero-initialized memory chained off of the given context.">rzalloc_size</a>(ctx, <span class="keyword">sizeof</span>(type))</div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="standalone__scaffolding_8h.html#a167d722df1056642076cfc949682c56b">_mesa_new_shader()</a>, <a class="el" href="classloop__variable__state.html#a70baf5d46006f24956f4d416dd09c9f0">loop_variable_state::insert()</a>, <a class="el" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="link__uniform__block__active__visitor_8cpp.html#ac814db4bf050ed491c44497686b5e081">process_block()</a>, and <a class="el" href="test__optpass_8h.html#a3fe803092be29c024e2213631e23e353">test_optpass()</a>.</p>

</div>
</div>
<a class="anchor" id="af27f97db91b041ad60bcf6a7ff663156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rzalloc_array</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ctx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((type *) <a class="el" href="ralloc_8h.html#a12c3f10245853c0bde6883e5365e4012">rzalloc_array_size</a>(ctx, sizeof(type), count))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a zero-initialized array chained off the given context. </p>
<p>Similar to <code>calloc</code>.</p>
<p>More than a convenience function, this also checks for integer overflow when multiplying <code>sizeof(type)</code> and <code>count</code>. This is necessary for security.</p>
<p>This is equivalent to: </p>
<div class="fragment"><div class="line">((type *) <a class="code" href="ralloc_8c.html#a12c3f10245853c0bde6883e5365e4012" title="Allocate a zero-initialized array chained off the given context.">rzalloc_array_size</a>(ctx, <span class="keyword">sizeof</span>(type), count)</div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="linker_8h.html#a87697e0a9d37fa9b9fa1b54593defa87">link_assign_uniform_locations()</a>, and <a class="el" href="link__varyings_8h.html#a11f5c95a76eded682bdcbb5c571c4a67">store_tfeedback_info()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a013e8df0993ef0373cfa7cde6c302d53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ralloc_array_size </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for an array chained off the given context. </p>
<p>Similar to <code>calloc</code>, but does not initialize the memory to zero.</p>
<p>More than a convenience function, this also checks for integer overflow when multiplying <code>size</code> and <code>count</code>. This is necessary for security. </p>

<p>References <a class="el" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3">ralloc_size()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a013e8df0993ef0373cfa7cde6c302d53_cgraph.png" border="0" usemap="#ralloc_8h_a013e8df0993ef0373cfa7cde6c302d53_cgraph" alt=""/></div>
<map name="ralloc_8h_a013e8df0993ef0373cfa7cde6c302d53_cgraph" id="ralloc_8h_a013e8df0993ef0373cfa7cde6c302d53_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="174,31,258,57"/><area shape="rect" id="node5" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="312,5,389,32"/><area shape="rect" id="node7" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="307,56,394,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aedc315b946d7bdb33ef44c4b991174ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ralloc_asprintf </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print to a string. </p>
<p>This is analogous to <code>sprintf</code>, but allocates enough space (using <code>ctx</code> as the context) for the resulting string.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly allocated string. </dd></dl>

</div>
</div>
<a class="anchor" id="abbfca8fae6b0d1aab2a83d3ce993b9a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ralloc_asprintf_append </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append formatted text to the supplied string. </p>
<p>This is equivalent to </p>
<div class="fragment"><div class="line"><a class="code" href="ralloc_8c.html#a76cc5ff6a33055e7bed53f145d902e97">ralloc_asprintf_rewrite_tail</a>(str, strlen(*str), fmt, ...)</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="ralloc_8h.html#aedc315b946d7bdb33ef44c4b991174ea" title="Print to a string.">ralloc_asprintf</a> </dd>
<dd>
<a class="el" href="ralloc_8h.html#a2980b62e5f650ff720d26793c905c9df" title="Rewrite the tail of an existing string, starting at a given index.">ralloc_asprintf_rewrite_tail</a> </dd>
<dd>
<a class="el" href="ralloc_8h.html#a81efd739143e83e06e3f6b3da7f943bf" title="Concatenate two strings, allocating the necessary space.">ralloc_strcat</a></dd></dl>
<p><code>str</code> will be updated to the new pointer unless allocation fails.</p>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2980b62e5f650ff720d26793c905c9df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ralloc_asprintf_rewrite_tail </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the tail of an existing string, starting at a given index. </p>
<p>Overwrites the contents of *str starting at <code>start</code> with newly formatted text, including a new null-terminator. Allocates more memory as necessary.</p>
<p>This can be used to append formatted text when the length of the existing string is already known, saving a strlen() call.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="ralloc_8h.html#abbfca8fae6b0d1aab2a83d3ce993b9a6" title="Append formatted text to the supplied string.">ralloc_asprintf_append</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be updated. </td></tr>
    <tr><td class="paramname">start</td><td>The index to start appending new data at. </td></tr>
    <tr><td class="paramname">fmt</td><td>A printf-style formatting string</td></tr>
  </table>
  </dd>
</dl>
<p><code>str</code> will be updated to the new pointer unless allocation fails. <code>start</code> will be increased by the length of the newly formatted text.</p>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0178b0bdc429496e03dc3682cfdb25cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ralloc_autofree_context </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a context whose memory will be automatically freed at program exit. </p>
<p>The first call to this function creates a context and registers a handler to free it using <code>atexit</code>. This may cause trouble if used in a library loaded with <code>dlopen</code>. </p>

<p>References <a class="el" href="ralloc_8c.html#afbdb8645cc0167fb09a0da5ba96f9801">autofree()</a>, <a class="el" href="ralloc_8c.html#ac90493a642839156e625183f61d621bc">autofree_context</a>, and <a class="el" href="ralloc_8c.html#a38530c9f4ef437290b8acd706b858410">ralloc_context()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a0178b0bdc429496e03dc3682cfdb25cb_cgraph.png" border="0" usemap="#ralloc_8h_a0178b0bdc429496e03dc3682cfdb25cb_cgraph" alt=""/></div>
<map name="ralloc_8h_a0178b0bdc429496e03dc3682cfdb25cb_cgraph" id="ralloc_8h_a0178b0bdc429496e03dc3682cfdb25cb_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#afbdb8645cc0167fb09a0da5ba96f9801" title="autofree" alt="" coords="228,56,297,83"/><area shape="rect" id="node13" href="ralloc_8c.html#a38530c9f4ef437290b8acd706b858410" title="Allocate a new ralloc context." alt="" coords="211,107,314,133"/><area shape="rect" id="node5" href="ralloc_8c.html#a280f5ecb6525a10e479c0b7c4ff89690" title="Free a piece of ralloc&#45;managed memory." alt="" coords="364,56,447,83"/><area shape="rect" id="node7" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="501,107,587,133"/><area shape="rect" id="node9" href="ralloc_8c.html#aa9f5466d1f5d3f1d2e706fd1b7f46b0a" title="unlink_block" alt="" coords="497,5,591,32"/><area shape="rect" id="node11" href="ralloc_8c.html#a839faa4b9da078e336f8d5e6b211eb2c" title="unsafe_free" alt="" coords="499,56,589,83"/><area shape="rect" id="node15" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="363,107,447,133"/><area shape="rect" id="node17" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="505,157,583,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a38530c9f4ef437290b8acd706b858410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ralloc_context </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new ralloc context. </p>
<p>While any ralloc'd pointer can be used as a context, sometimes it is useful to simply allocate a context with no associated memory.</p>
<p>It is equivalent to: </p>
<div class="fragment"><div class="line">((type *) <a class="code" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context.">ralloc_size</a>(ctx, 0)</div>
</div><!-- fragment --> 
<p>References <a class="el" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3">ralloc_size()</a>.</p>

<p>Referenced by <a class="el" href="ir_8h.html#a732e9ee7904fa3345e3e41e7c4771f18">_mesa_glsl_initialize_functions()</a>, <a class="el" href="loop__controls_8cpp.html#a5111b857130a5d19dc90197dcbcdf19f">calculate_iterations()</a>, <a class="el" href="opt__dead__code__local_8cpp.html#a6752a72dc50bd6b06ea83470714c3e3f">dead_code_local_basic_block()</a>, <a class="el" href="opt__structure__splitting_8cpp.html#a613d55aa3cfd58ddeadcb5bfaa92e46a">do_structure_splitting()</a>, <a class="el" href="structglsl__symbol__table.html#a7c0237591e023b33480e3dd59d8708c7">glsl_symbol_table::glsl_symbol_table()</a>, <a class="el" href="classhas__recursion__visitor.html#ad6feb105aae295c02a6dd779df9fea78">has_recursion_visitor::has_recursion_visitor()</a>, <a class="el" href="classir__array__reference__visitor.html#af96cdb7cc8a9a3bb8512805c54b50a5c">ir_array_reference_visitor::ir_array_reference_visitor()</a>, <a class="el" href="classir__print__visitor.html#af65a7bf29505cda860ba6e1b685148af">ir_print_visitor::ir_print_visitor()</a>, <a class="el" href="classir__variable__refcount__visitor.html#a1ed936c4bc15056b505b509bfa83382b">ir_variable_refcount_visitor::ir_variable_refcount_visitor()</a>, <a class="el" href="linker_8h.html#a1ab29b5d63f0b9e568ab81a528e0fe48">link_set_uniform_initializers()</a>, <a class="el" href="program_8h.html#afc0379dac600d4977ea2e7ae44096f1a">link_shaders()</a>, <a class="el" href="opt__array__splitting_8cpp.html#a9afe02479db22138e42085ec00a32685">optimize_split_arrays()</a>, <a class="el" href="classoutput__read__remover.html#a017004f04f7e0eba770de8cdade69867">output_read_remover::output_read_remover()</a>, <a class="el" href="ralloc_8h.html#a0178b0bdc429496e03dc3682cfdb25cb">ralloc_autofree_context()</a>, and <a class="el" href="classir__reader.html#abf53ac0c7a6e08b76bf6a8635ca5934d">ir_reader::read()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a38530c9f4ef437290b8acd706b858410_cgraph.png" border="0" usemap="#ralloc_8h_a38530c9f4ef437290b8acd706b858410_cgraph" alt=""/></div>
<map name="ralloc_8h_a38530c9f4ef437290b8acd706b858410_cgraph" id="ralloc_8h_a38530c9f4ef437290b8acd706b858410_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="158,31,242,57"/><area shape="rect" id="node5" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="296,5,373,32"/><area shape="rect" id="node7" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="291,56,378,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a280f5ecb6525a10e479c0b7c4ff89690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ralloc_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a piece of ralloc-managed memory. </p>
<p>This will also free the memory of any children allocated this context. </p>

<p>References <a class="el" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c">get_header()</a>, <a class="el" href="ralloc_8c.html#aa9f5466d1f5d3f1d2e706fd1b7f46b0a">unlink_block()</a>, and <a class="el" href="ralloc_8c.html#a839faa4b9da078e336f8d5e6b211eb2c">unsafe_free()</a>.</p>

<p>Referenced by <a class="el" href="ir_8h.html#a832b79de8aac88f62a965aaabf0b739c">_mesa_glsl_release_functions()</a>, <a class="el" href="ralloc_8c.html#afbdb8645cc0167fb09a0da5ba96f9801">autofree()</a>, <a class="el" href="loop__controls_8cpp.html#a5111b857130a5d19dc90197dcbcdf19f">calculate_iterations()</a>, <a class="el" href="main_8cpp.html#af583b47bb85a98c84438a5623c75322e">compile_shader()</a>, <a class="el" href="opt__dead__code__local_8cpp.html#a6752a72dc50bd6b06ea83470714c3e3f">dead_code_local_basic_block()</a>, <a class="el" href="opt__structure__splitting_8cpp.html#a613d55aa3cfd58ddeadcb5bfaa92e46a">do_structure_splitting()</a>, <a class="el" href="ir__function__detect__recursion_8cpp.html#a4a70cd7f63f2d706681309c9fb0c0558">emit_errors_linked()</a>, <a class="el" href="ir__function__detect__recursion_8cpp.html#a236f31245c21881743ef08c94fcaecba">emit_errors_unlinked()</a>, <a class="el" href="linker_8h.html#a87697e0a9d37fa9b9fa1b54593defa87">link_assign_uniform_locations()</a>, <a class="el" href="linker_8h.html#a1ab29b5d63f0b9e568ab81a528e0fe48">link_set_uniform_initializers()</a>, <a class="el" href="program_8h.html#afc0379dac600d4977ea2e7ae44096f1a">link_shaders()</a>, <a class="el" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="ast__function_8cpp.html#aca3dabf9ba557c9343356ed333cb3796">no_matching_function_error()</a>, <a class="el" href="classsymbol__table__entry.html#aabcc4b82f8e02d7a253d2df4aff4ba9c">symbol_table_entry::operator delete()</a>, <a class="el" href="classast__node.html#a79a3155d6341f6ae2fdddd5f653e2721">ast_node::operator delete()</a>, <a class="el" href="structglsl__symbol__table.html#a491b017090b719112a4c943be6604106">glsl_symbol_table::operator delete()</a>, <a class="el" href="classfunction.html#a8bd51dfec5b53ef7ce0fa2c6590edaa2">function::operator delete()</a>, <a class="el" href="structast__type__qualifier.html#a2075f9a1cc69422aab887f4409318e4c">ast_type_qualifier::operator delete()</a>, <a class="el" href="opt__array__splitting_8cpp.html#a9afe02479db22138e42085ec00a32685">optimize_split_arrays()</a>, <a class="el" href="classprogram__resource__visitor.html#ae725b4484ae60544f86b6ac6f805c0eb">program_resource_visitor::process()</a>, <a class="el" href="classir__reader.html#abf53ac0c7a6e08b76bf6a8635ca5934d">ir_reader::read()</a>, <a class="el" href="builtin__function_8cpp.html#a33f071334daae3bc6f103b6afd5712bd">read_builtins()</a>, <a class="el" href="link__varyings_8h.html#a11f5c95a76eded682bdcbb5c571c4a67">store_tfeedback_info()</a>, <a class="el" href="test__optpass_8h.html#a3fe803092be29c024e2213631e23e353">test_optpass()</a>, <a class="el" href="structglsl__symbol__table.html#a54fb6b58e4688e1cd7cc8db74fecac8a">glsl_symbol_table::~glsl_symbol_table()</a>, <a class="el" href="classhas__recursion__visitor.html#a993b7426ed72e968f44757cd44fd580f">has_recursion_visitor::~has_recursion_visitor()</a>, <a class="el" href="classir__array__reference__visitor.html#aa6a9659e6f4598439eaf4225e471aec9">ir_array_reference_visitor::~ir_array_reference_visitor()</a>, <a class="el" href="classir__print__visitor.html#a9fd8eab9c8ee6212a4a44cca2e61c58a">ir_print_visitor::~ir_print_visitor()</a>, <a class="el" href="classir__variable__refcount__visitor.html#aae9759ef41741f33d8e37d6193d9d0fd">ir_variable_refcount_visitor::~ir_variable_refcount_visitor()</a>, <a class="el" href="classloop__state.html#ae0e60dce4cb97908718ad6143c276862">loop_state::~loop_state()</a>, and <a class="el" href="classoutput__read__remover.html#aa53fb1832c8aea402fda64c4fa3c0ff6">output_read_remover::~output_read_remover()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a280f5ecb6525a10e479c0b7c4ff89690_cgraph.png" border="0" usemap="#ralloc_8h_a280f5ecb6525a10e479c0b7c4ff89690_cgraph" alt=""/></div>
<map name="ralloc_8h_a280f5ecb6525a10e479c0b7c4ff89690_cgraph" id="ralloc_8h_a280f5ecb6525a10e479c0b7c4ff89690_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="141,5,227,32"/><area shape="rect" id="node5" href="ralloc_8c.html#aa9f5466d1f5d3f1d2e706fd1b7f46b0a" title="unlink_block" alt="" coords="137,56,231,83"/><area shape="rect" id="node7" href="ralloc_8c.html#a839faa4b9da078e336f8d5e6b211eb2c" title="unsafe_free" alt="" coords="139,107,229,133"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9f820b482c39fab77bf884a420aeb4f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ralloc_parent </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the given pointer's ralloc context. </p>

<p>References <a class="el" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c">get_header()</a>, <a class="el" href="structralloc__header.html#acdc590f258d08030a1476d14a00723f4">ralloc_header::parent</a>, and <a class="el" href="ralloc_8c.html#a8f3a4f9616cdf3fd5c48312983565113">PTR_FROM_HEADER</a>.</p>

<p>Referenced by <a class="el" href="namespaceir__builder.html#a888d3a1315316c1674017fbe3669a4c3">ir_builder::assign()</a>, <a class="el" href="classir__function__signature.html#a2a9b27f70a7ad4d2e52c708b6f9c906f">ir_function_signature::constant_expression_value()</a>, <a class="el" href="classir__expression.html#aef40d8e9832c26af7d151495300d656b">ir_expression::constant_expression_value()</a>, <a class="el" href="classir__swizzle.html#a5b5d32f28590145b71ece847fc5c25ad">ir_swizzle::constant_expression_value()</a>, <a class="el" href="classir__dereference__variable.html#a25b2bc5bc923b0fc83e5736b400d5edd">ir_dereference_variable::constant_expression_value()</a>, <a class="el" href="classir__dereference__array.html#a009f68ad3c9b05c09fd19ebb37105411">ir_dereference_array::constant_expression_value()</a>, <a class="el" href="ast__function_8cpp.html#a7866d831b46b6b755032d6138c9beed5">convert_component()</a>, <a class="el" href="classvariable__index__to__cond__assign__visitor.html#a677187a47d2c2127906d04d39d39c899">variable_index_to_cond_assign_visitor::convert_dereference_array()</a>, <a class="el" href="classir__vec__index__to__cond__assign__visitor.html#a4e910a8370e6346d18720e9a60982bb7">ir_vec_index_to_cond_assign_visitor::convert_vector_extract_to_cond_assign()</a>, <a class="el" href="classir__vec__index__to__swizzle__visitor.html#a39a5848cdfc47d4e1990f27cc4850170">ir_vec_index_to_swizzle_visitor::convert_vector_extract_to_swizzle()</a>, <a class="el" href="classir__swizzle.html#aa4465f5adef28044c78521571db739a1">ir_swizzle::create()</a>, <a class="el" href="classlower__clip__distance__visitor.html#aaf833a7a1727c3d616080e188eb44a5c">lower_clip_distance_visitor::create_indices()</a>, <a class="el" href="linker_8cpp.html#ae4df43e246838a5cc8bbdd02f24a5615">cross_validate_globals()</a>, <a class="el" href="classir__builder_1_1deref.html#ad3972b951c25f1b39c48a1f995d4abc2">ir_builder::deref::deref()</a>, <a class="el" href="ast__function_8cpp.html#a5fb152e351cd5721ab69858ffaeb284c">dereference_component()</a>, <a class="el" href="opt__structure__splitting_8cpp.html#a613d55aa3cfd58ddeadcb5bfaa92e46a">do_structure_splitting()</a>, <a class="el" href="namespaceir__builder.html#a048b56be6e086b54f02bd81c55e1320d">ir_builder::expr()</a>, <a class="el" href="classlower__clip__distance__visitor.html#a860b08a3af0445bcd2e45ac10743e597">lower_clip_distance_visitor::fix_lhs()</a>, <a class="el" href="structassignment__generator.html#abe587e8aab81356136f1fffc281b4716">assignment_generator::generate()</a>, <a class="el" href="classir__call.html#a747e4ba8cf7e1f6b3da8c13b9ae5afc3">ir_call::generate_inline()</a>, <a class="el" href="loop__analysis_8cpp.html#a3b1cbadbb24c7cb6c48963d79e552093">get_basic_induction_increment()</a>, <a class="el" href="ast__to__hir_8cpp.html#a0f986767af0b81aaa78291f8f137f4b5">get_lvalue_copy()</a>, <a class="el" href="classlower__noise__visitor.html#a1acbc9f16cffc5e90acca07e9c355a02">lower_noise_visitor::handle_rvalue()</a>, <a class="el" href="classvector__insert__visitor.html#a5b2b18d9fd0fdae720165b0506c13381">vector_insert_visitor::handle_rvalue()</a>, <a class="el" href="classir__expression__flattening__visitor.html#adf292adcb464ddefe2e33f24221d087a">ir_expression_flattening_visitor::handle_rvalue()</a>, <a class="el" href="classlower__clip__distance__visitor.html#a6d400f13328096e60e060cb79ffa95a8">lower_clip_distance_visitor::handle_rvalue()</a>, <a class="el" href="classderef__replacer.html#a88d988cd6d6f2a45ffacd15290f9c111">deref_replacer::handle_rvalue()</a>, <a class="el" href="classvariable__index__to__cond__assign__visitor.html#ae0cb3fe2a5586e3e04efc1bda5c1f8ff">variable_index_to_cond_assign_visitor::handle_rvalue()</a>, <a class="el" href="namespaceir__builder.html#a6f601c4a3618ade9f2f4887856e145b5">ir_builder::if_tree()</a>, <a class="el" href="classloop__variable__state.html#a70baf5d46006f24956f4d416dd09c9f0">loop_variable_state::insert()</a>, <a class="el" href="classir__dereference__array.html#aaf04446f84fcf3ca9f3b0c10940deccd">ir_dereference_array::ir_dereference_array()</a>, <a class="el" href="classir__dereference__record.html#a06663b795eebb90486be5217de9e3d80">ir_dereference_record::ir_dereference_record()</a>, <a class="el" href="classlower__discard__flow__visitor.html#a15ba58202a06243e4fd9feb55da15070">lower_discard_flow_visitor::lower_discard_flow_visitor()</a>, <a class="el" href="classir__builder_1_1operand.html#a4d308859d0027390f036aa8f11f8d30b">ir_builder::operand::operand()</a>, <a class="el" href="opt__array__splitting_8cpp.html#a9afe02479db22138e42085ec00a32685">optimize_split_arrays()</a>, <a class="el" href="opt__dead__code__local_8cpp.html#a6d52bb1f02a1522b3ea84e42dfa5b0c4">process_assignment()</a>, <a class="el" href="classir__sampler__replacement__visitor.html#a0d5554ae63e7919170c91e1bc506a675">ir_sampler_replacement_visitor::replace_deref()</a>, <a class="el" href="opt__function__inlining_8cpp.html#ac2927df08f4b81fd68abb71745d171cf">replace_return_with_assignment()</a>, <a class="el" href="ralloc_8h.html#a3a1adf0ae73bf982e8aceff21b47959c">reralloc_size()</a>, <a class="el" href="namespaceir__builder.html#a72d2dda16789bb4d8730ae4e5ddbb159">ir_builder::saturate()</a>, <a class="el" href="structswitch__generator.html#a95c0aad3519c9a07d456116e4fc2e3dd">switch_generator::switch_generator()</a>, <a class="el" href="namespaceir__builder.html#a559a4ac16831f7343a7216cd3f94ca76">ir_builder::swizzle()</a>, <a class="el" href="namespaceir__builder.html#adb00b2733e753e85b9f8c0a598f62183">ir_builder::swizzle_for_size()</a>, <a class="el" href="classoutput__read__remover.html#afd0fb0eaa5cdff1f00ccd29e0b2f5fb7">output_read_remover::visit()</a>, <a class="el" href="classir__validate.html#aadeedd2534633c948c6e23e7062ec49c">ir_validate::visit()</a>, <a class="el" href="classlower__clip__distance__visitor.html#a0b6a5c26016ce610cccd047580eb5ddc">lower_clip_distance_visitor::visit()</a>, <a class="el" href="classloop__unroll__visitor.html#a23e95944f90cd8dd9113d9cba10f6477">loop_unroll_visitor::visit_leave()</a>, <a class="el" href="classir__mat__op__to__vec__visitor.html#acf95d75d8a5fc2f07f98e28f292d422a">ir_mat_op_to_vec_visitor::visit_leave()</a>, <a class="el" href="classlower__texture__projection__visitor.html#a70d81357187764a786e5bbb775c05e79">lower_texture_projection_visitor::visit_leave()</a>, <a class="el" href="classlower__clip__distance__visitor.html#a7eb7f01949f7e1ed19c97914272c28bc">lower_clip_distance_visitor::visit_leave()</a>, <a class="el" href="classir__validate.html#a9744c52a1c37ded4668ae55443b6a331">ir_validate::visit_leave()</a>, <a class="el" href="classir__if__to__cond__assign__visitor.html#a775db447cfa80b127933d10b30b05263">ir_if_to_cond_assign_visitor::visit_leave()</a>, and <a class="el" href="classlower__discard__visitor.html#a31f44317f271f824dffcf13f15a0bb36">lower_discard_visitor::visit_leave()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a9f820b482c39fab77bf884a420aeb4f2_cgraph.png" border="0" usemap="#ralloc_8h_a9f820b482c39fab77bf884a420aeb4f2_cgraph" alt=""/></div>
<map name="ralloc_8h_a9f820b482c39fab77bf884a420aeb4f2_cgraph" id="ralloc_8h_a9f820b482c39fab77bf884a420aeb4f2_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="150,5,237,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa90aa1c7c5d666c1a09aca7450d9edad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ralloc_set_destructor </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>destructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a callback to occur just before an object is freed. </p>

<p>References <a class="el" href="structralloc__header.html#a91e92ce67bc5c6aad3372738803b8332">ralloc_header::destructor</a>, and <a class="el" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c">get_header()</a>.</p>

<p>Referenced by <a class="el" href="structglsl__symbol__table.html#a491b017090b719112a4c943be6604106">glsl_symbol_table::operator delete()</a>, <a class="el" href="structglsl__symbol__table.html#a733944fa40e55a17fcdf84ed036fc2ea">glsl_symbol_table::operator new()</a>, and <a class="el" href="classloop__variable__state.html#a8e98a34c5531d0055b1a9cde4f6895f9">loop_variable_state::operator new()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_aa90aa1c7c5d666c1a09aca7450d9edad_cgraph.png" border="0" usemap="#ralloc_8h_aa90aa1c7c5d666c1a09aca7450d9edad_cgraph" alt=""/></div>
<map name="ralloc_8h_aa90aa1c7c5d666c1a09aca7450d9edad_cgraph" id="ralloc_8h_aa90aa1c7c5d666c1a09aca7450d9edad_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="198,5,285,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a03d668aa9fce8d82182c2bfbd3f2a4e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ralloc_size </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory chained off of the given context. </p>
<p>This is the core allocation routine which is used by all others. It simply allocates storage for <code>size</code> bytes and returns the pointer, similar to <code>malloc</code>. </p>

<p>References <a class="el" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43">add_child()</a>, <a class="el" href="ralloc_8c.html#a3f66c64c3c72034ee0c901bd685bb179">CANARY</a>, <a class="el" href="structralloc__header.html#af869877253927a111581ef36f2335b25">ralloc_header::canary</a>, <a class="el" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c">get_header()</a>, <a class="el" href="structralloc__header.html#acdc590f258d08030a1476d14a00723f4">ralloc_header::parent</a>, and <a class="el" href="ralloc_8c.html#a8f3a4f9616cdf3fd5c48312983565113">PTR_FROM_HEADER</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp.html#ac88d6df7128fd450a0a503e18b53ba3e">load_text_file()</a>, <a class="el" href="classsymbol__table__entry.html#a27984ebc3f700668e09ec7856ae44f6b">symbol_table_entry::operator new()</a>, <a class="el" href="structglsl__symbol__table.html#a733944fa40e55a17fcdf84ed036fc2ea">glsl_symbol_table::operator new()</a>, <a class="el" href="classloop__variable__state.html#a8e98a34c5531d0055b1a9cde4f6895f9">loop_variable_state::operator new()</a>, <a class="el" href="classfunction.html#ad61c097a653f4f03dcfa1f619af50a17">function::operator new()</a>, <a class="el" href="ralloc_8h.html#a013e8df0993ef0373cfa7cde6c302d53">ralloc_array_size()</a>, <a class="el" href="ralloc_8h.html#a38530c9f4ef437290b8acd706b858410">ralloc_context()</a>, <a class="el" href="ralloc_8h.html#ac75be6b63118900b80715f9cd472a984">ralloc_vasprintf()</a>, <a class="el" href="ralloc_8h.html#a3a1adf0ae73bf982e8aceff21b47959c">reralloc_size()</a>, and <a class="el" href="ralloc_8h.html#a04d6d49f08bc3721b2c5dd1faac23a1c">rzalloc_size()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a03d668aa9fce8d82182c2bfbd3f2a4e3_cgraph.png" border="0" usemap="#ralloc_8h_a03d668aa9fce8d82182c2bfbd3f2a4e3_cgraph" alt=""/></div>
<map name="ralloc_8h_a03d668aa9fce8d82182c2bfbd3f2a4e3_cgraph" id="ralloc_8h_a03d668aa9fce8d82182c2bfbd3f2a4e3_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="144,5,221,32"/><area shape="rect" id="node5" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="139,56,226,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8a5d6cd015f1bb09e1ffc6413ab4a326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ralloc_steal </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>new_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Steal" memory from one context, changing it to another. </p>
<p>This changes <code>ptr's</code> context to <code>new_ctx</code>. This is quite useful if memory is allocated out of a temporary context. </p>

<p>References <a class="el" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43">add_child()</a>, <a class="el" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c">get_header()</a>, <a class="el" href="structralloc__header.html#acdc590f258d08030a1476d14a00723f4">ralloc_header::parent</a>, and <a class="el" href="ralloc_8c.html#aa9f5466d1f5d3f1d2e706fd1b7f46b0a">unlink_block()</a>.</p>

<p>Referenced by <a class="el" href="builtin__function_8cpp.html#a30ea3b0ca8aaf434930e8b4dde90877f">_mesa_read_profile()</a>, <a class="el" href="linker_8cpp.html#a41b744f04debfd01820b1c10f75e19d1">link_intrastage_shaders()</a>, and <a class="el" href="ir_8cpp.html#ae341e75c11b8868864fa8b7ab032e491">steal_memory()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a8a5d6cd015f1bb09e1ffc6413ab4a326_cgraph.png" border="0" usemap="#ralloc_8h_a8a5d6cd015f1bb09e1ffc6413ab4a326_cgraph" alt=""/></div>
<map name="ralloc_8h_a8a5d6cd015f1bb09e1ffc6413ab4a326_cgraph" id="ralloc_8h_a8a5d6cd015f1bb09e1ffc6413ab4a326_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="151,5,228,32"/><area shape="rect" id="node5" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="146,56,233,83"/><area shape="rect" id="node7" href="ralloc_8c.html#aa9f5466d1f5d3f1d2e706fd1b7f46b0a" title="unlink_block" alt="" coords="142,107,237,133"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a81efd739143e83e06e3f6b3da7f943bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ralloc_strcat </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings, allocating the necessary space. </p>
<p>This appends <code>str</code> to <code>*dest</code>, similar to <code>strcat</code>, using ralloc_resize to expand <code>*dest</code> to the appropriate size. <code>dest</code> will be updated to the new pointer unless allocation fails.</p>
<p>The result will always be null-terminated.</p>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="ralloc_8c.html#aafc50d975c2ed969ac72872a4be70144">cat()</a>.</p>

<p>Referenced by <a class="el" href="glsl__parser__extras_8cpp.html#aa25ddbf1acbfec0effb16f27e01ddc7c">_mesa_glsl_msg()</a>, <a class="el" href="program_8h.html#aea74b3d0ae92f36c940f2fb43efffeeb">linker_error()</a>, <a class="el" href="program_8h.html#a6f9ce800d889f1deba8864b1adbd0342">linker_warning()</a>, and <a class="el" href="ir_8h.html#a201de0e9a762b67e9b6d313add6c8cee">prototype_string()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a81efd739143e83e06e3f6b3da7f943bf_cgraph.png" border="0" usemap="#ralloc_8h_a81efd739143e83e06e3f6b3da7f943bf_cgraph" alt=""/></div>
<map name="ralloc_8h_a81efd739143e83e06e3f6b3da7f943bf_cgraph" id="ralloc_8h_a81efd739143e83e06e3f6b3da7f943bf_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#aafc50d975c2ed969ac72872a4be70144" title="cat" alt="" coords="147,5,187,32"/><area shape="rect" id="node5" href="ralloc_8c.html#ab9a56787f0f0d1421c708a57383eae25" title="resize" alt="" coords="235,5,293,32"/><area shape="rect" id="node7" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="342,5,429,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0565a6a6f82e3ca9fbae2ede2ee8ac39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ralloc_strdup </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a string, allocating the memory from the given context. </p>

<p>References <a class="el" href="ralloc_8h.html#a6818ee56f93509fc276427b91dae6cc2">ralloc_array</a>.</p>

<p>Referenced by <a class="el" href="link__varyings_8h.html#afec41d0773ef307f2937b1e6c05e1c38">assign_varying_locations()</a>, <a class="el" href="classast__interface__block.html#aa5245c0485b84b0502a56e94766c11b6">ast_interface_block::hir()</a>, <a class="el" href="classir__dereference__record.html#a848678e214acbff9c54d491a28e69a7e">ir_dereference_record::ir_dereference_record()</a>, <a class="el" href="classir__function.html#aafe9af094fd225678cb6a9768d147967">ir_function::ir_function()</a>, <a class="el" href="classir__variable.html#ad128688a9c892e6e06d67e2c1bb85530">ir_variable::ir_variable()</a>, <a class="el" href="linker_8h.html#ac24e5d2a63f74e49dfd25f72e9275da3">link_cross_validate_uniform_block()</a>, <a class="el" href="program_8h.html#afc0379dac600d4977ea2e7ae44096f1a">link_shaders()</a>, <a class="el" href="linker_8h.html#aef3e3e62d7cadff0e6d9b295965137f1">link_uniform_blocks()</a>, <a class="el" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="classprogram__resource__visitor.html#ae725b4484ae60544f86b6ac6f805c0eb">program_resource_visitor::process()</a>, <a class="el" href="classs__expression.html#add896f8db24b6cab521d06f7d2ed225c">s_expression::read_expression()</a>, <a class="el" href="classflatten__named__interface__blocks__declarations.html#a25ea81baf7bc25720d68d8065971d7f3">flatten_named_interface_blocks_declarations::run()</a>, <a class="el" href="classtfeedback__decl.html#a4700027f0001fdec517a0cb2293bde7e">tfeedback_decl::store()</a>, and <a class="el" href="classlower__clip__distance__visitor.html#a0b6a5c26016ce610cccd047580eb5ddc">lower_clip_distance_visitor::visit()</a>.</p>

</div>
</div>
<a class="anchor" id="a76d8ab2458cbde4f99e35c36e1c6cc11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ralloc_strncat </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings, allocating the necessary space. </p>
<p>This appends at most <code>n</code> bytes of <code>str</code> to <code>*dest</code>, using ralloc_resize to expand <code>*dest</code> to the appropriate size. <code>dest</code> will be updated to the new pointer unless allocation fails.</p>
<p>The result will always be null-terminated; <code>str</code> does not need to be null terminated if it is longer than <code>n</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="ralloc_8c.html#aafc50d975c2ed969ac72872a4be70144">cat()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a76d8ab2458cbde4f99e35c36e1c6cc11_cgraph.png" border="0" usemap="#ralloc_8h_a76d8ab2458cbde4f99e35c36e1c6cc11_cgraph" alt=""/></div>
<map name="ralloc_8h_a76d8ab2458cbde4f99e35c36e1c6cc11_cgraph" id="ralloc_8h_a76d8ab2458cbde4f99e35c36e1c6cc11_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#aafc50d975c2ed969ac72872a4be70144" title="cat" alt="" coords="155,5,195,32"/><area shape="rect" id="node5" href="ralloc_8c.html#ab9a56787f0f0d1421c708a57383eae25" title="resize" alt="" coords="243,5,301,32"/><area shape="rect" id="node7" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="350,5,437,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac413d04bbe87e8d99ab60fa0abe375da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ralloc_strndup </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a string, allocating the memory from the given context. </p>
<p>Like <code>strndup</code>, at most <code>n</code> characters are copied. If <code>str</code> is longer than <code>n</code> characters, <code>n</code> are copied, and a termining <code>'\0'</code> byte is added. </p>

<p>References <a class="el" href="ralloc_8h.html#a6818ee56f93509fc276427b91dae6cc2">ralloc_array</a>.</p>

<p>Referenced by <a class="el" href="classtfeedback__decl.html#ad633a3cb3a77743483749d437509605d">tfeedback_decl::init()</a>.</p>

</div>
</div>
<a class="anchor" id="ac75be6b63118900b80715f9cd472a984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char char* ralloc_vasprintf </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print to a string, given a va_list. </p>
<p>This is analogous to <code>vsprintf</code>, but allocates enough space (using <code>ctx</code> as the context) for the resulting string.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly allocated string. </dd></dl>

<p>References <a class="el" href="ralloc_8c.html#a0d69b86f0cf5203cc5bf729b0f171bbe">printf_length()</a>, and <a class="el" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3">ralloc_size()</a>.</p>

<p>Referenced by <a class="el" href="ralloc_8c.html#a59d30deb8469f39591e3edb73c7b3709">ralloc_asprintf()</a>, and <a class="el" href="ralloc_8h.html#a8ba98d7ec76e48fe68428e87099631b5">ralloc_vasprintf_rewrite_tail()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_ac75be6b63118900b80715f9cd472a984_cgraph.png" border="0" usemap="#ralloc_8h_ac75be6b63118900b80715f9cd472a984_cgraph" alt=""/></div>
<map name="ralloc_8h_ac75be6b63118900b80715f9cd472a984_cgraph" id="ralloc_8h_ac75be6b63118900b80715f9cd472a984_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a0d69b86f0cf5203cc5bf729b0f171bbe" title="printf_length" alt="" coords="165,5,259,32"/><area shape="rect" id="node5" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="170,56,254,83"/><area shape="rect" id="node7" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="312,31,389,57"/><area shape="rect" id="node9" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="307,81,394,108"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a414ae58d2f6a0cb6e04b3bf71d3193da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bool ralloc_vasprintf_append </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append formatted text to the supplied string, given a va_list. </p>
<p>This is equivalent to </p>
<div class="fragment"><div class="line"><a class="code" href="ralloc_8c.html#ab178df8162cda12a67ffeaf4c588da19" title="Rewrite the tail of an existing string, starting at a given index.">ralloc_vasprintf_rewrite_tail</a>(str, strlen(*str), fmt, args)</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="ralloc_8h.html#ac75be6b63118900b80715f9cd472a984" title="Print to a string, given a va_list.">ralloc_vasprintf</a> </dd>
<dd>
<a class="el" href="ralloc_8h.html#a8ba98d7ec76e48fe68428e87099631b5" title="Rewrite the tail of an existing string, starting at a given index.">ralloc_vasprintf_rewrite_tail</a> </dd>
<dd>
<a class="el" href="ralloc_8h.html#a81efd739143e83e06e3f6b3da7f943bf" title="Concatenate two strings, allocating the necessary space.">ralloc_strcat</a></dd></dl>
<p><code>str</code> will be updated to the new pointer unless allocation fails.</p>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="ralloc_8c.html#ab178df8162cda12a67ffeaf4c588da19">ralloc_vasprintf_rewrite_tail()</a>.</p>

<p>Referenced by <a class="el" href="glsl__parser__extras_8cpp.html#aa25ddbf1acbfec0effb16f27e01ddc7c">_mesa_glsl_msg()</a>, <a class="el" href="program_8h.html#aea74b3d0ae92f36c940f2fb43efffeeb">linker_error()</a>, <a class="el" href="program_8h.html#a6f9ce800d889f1deba8864b1adbd0342">linker_warning()</a>, and <a class="el" href="ralloc_8c.html#a6db914c76a6e476346878a922a7bccfd">ralloc_asprintf_append()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a414ae58d2f6a0cb6e04b3bf71d3193da_cgraph.png" border="0" usemap="#ralloc_8h_a414ae58d2f6a0cb6e04b3bf71d3193da_cgraph" alt=""/></div>
<map name="ralloc_8h_a414ae58d2f6a0cb6e04b3bf71d3193da_cgraph" id="ralloc_8h_a414ae58d2f6a0cb6e04b3bf71d3193da_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#ab178df8162cda12a67ffeaf4c588da19" title="Rewrite the tail of an existing string, starting at a given index." alt="" coords="214,56,394,83"/><area shape="rect" id="node5" href="ralloc_8c.html#a0d69b86f0cf5203cc5bf729b0f171bbe" title="printf_length" alt="" coords="603,5,696,32"/><area shape="rect" id="node7" href="ralloc_8c.html#a06fbe0c25dc86de1f27c42e1d1c0dd74" title="Print to a string, given a va_list." alt="" coords="443,56,554,83"/><area shape="rect" id="node16" href="ralloc_8c.html#ab9a56787f0f0d1421c708a57383eae25" title="resize" alt="" coords="470,107,527,133"/><area shape="rect" id="node10" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="607,56,691,83"/><area shape="rect" id="node12" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="749,56,827,83"/><area shape="rect" id="node14" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="745,107,831,133"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8ba98d7ec76e48fe68428e87099631b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bool ralloc_vasprintf_rewrite_tail </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the tail of an existing string, starting at a given index. </p>
<p>Overwrites the contents of *str starting at <code>start</code> with newly formatted text, including a new null-terminator. Allocates more memory as necessary.</p>
<p>This can be used to append formatted text when the length of the existing string is already known, saving a strlen() call.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="ralloc_8h.html#a414ae58d2f6a0cb6e04b3bf71d3193da" title="Append formatted text to the supplied string, given a va_list.">ralloc_vasprintf_append</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be updated. </td></tr>
    <tr><td class="paramname">start</td><td>The index to start appending new data at. </td></tr>
    <tr><td class="paramname">fmt</td><td>A printf-style formatting string </td></tr>
    <tr><td class="paramname">args</td><td>A va_list containing the data to be formatted</td></tr>
  </table>
  </dd>
</dl>
<p><code>str</code> will be updated to the new pointer unless allocation fails. <code>start</code> will be increased by the length of the newly formatted text.</p>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="ralloc_8c.html#a0d69b86f0cf5203cc5bf729b0f171bbe">printf_length()</a>, <a class="el" href="ralloc_8c.html#a06fbe0c25dc86de1f27c42e1d1c0dd74">ralloc_vasprintf()</a>, and <a class="el" href="ralloc_8c.html#ab9a56787f0f0d1421c708a57383eae25">resize()</a>.</p>

<p>Referenced by <a class="el" href="ralloc_8c.html#a76cc5ff6a33055e7bed53f145d902e97">ralloc_asprintf_rewrite_tail()</a>, and <a class="el" href="ralloc_8h.html#a414ae58d2f6a0cb6e04b3bf71d3193da">ralloc_vasprintf_append()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a8ba98d7ec76e48fe68428e87099631b5_cgraph.png" border="0" usemap="#ralloc_8h_a8ba98d7ec76e48fe68428e87099631b5_cgraph" alt=""/></div>
<map name="ralloc_8h_a8ba98d7ec76e48fe68428e87099631b5_cgraph" id="ralloc_8h_a8ba98d7ec76e48fe68428e87099631b5_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a0d69b86f0cf5203cc5bf729b0f171bbe" title="printf_length" alt="" coords="395,5,488,32"/><area shape="rect" id="node5" href="ralloc_8c.html#a06fbe0c25dc86de1f27c42e1d1c0dd74" title="Print to a string, given a va_list." alt="" coords="235,56,346,83"/><area shape="rect" id="node14" href="ralloc_8c.html#ab9a56787f0f0d1421c708a57383eae25" title="resize" alt="" coords="262,107,319,133"/><area shape="rect" id="node8" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="399,56,483,83"/><area shape="rect" id="node10" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="541,56,619,83"/><area shape="rect" id="node12" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="537,107,623,133"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af37fae09221c71687f0cc2295d6b163f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* reralloc_array_size </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a ralloc-managed array, preserving data. </p>
<p>Similar to <code>realloc</code>. Unlike C89, passing 0 for <code>size</code> does not free the memory. Instead, it resizes it to a 0-byte ralloc context, just like calling ralloc_size(ctx, 0). This is different from talloc.</p>
<p>More than a convenience function, this also checks for integer overflow when multiplying <code>sizeof(type)</code> and <code>count</code>. This is necessary for security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context to use for new allocation. If <code>ptr</code> != NULL, it must be the same as ralloc_parent(<code>ptr</code>). </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the array to be resized. May be NULL. </td></tr>
    <tr><td class="paramname">size</td><td>The size of an individual element. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="ralloc_8c.html#a3a1adf0ae73bf982e8aceff21b47959c">reralloc_size()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_af37fae09221c71687f0cc2295d6b163f_cgraph.png" border="0" usemap="#ralloc_8h_af37fae09221c71687f0cc2295d6b163f_cgraph" alt=""/></div>
<map name="ralloc_8h_af37fae09221c71687f0cc2295d6b163f_cgraph" id="ralloc_8h_af37fae09221c71687f0cc2295d6b163f_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a3a1adf0ae73bf982e8aceff21b47959c" title="Resize a piece of ralloc&#45;managed memory, preserving data." alt="" coords="185,56,279,83"/><area shape="rect" id="node5" href="ralloc_8c.html#a9f820b482c39fab77bf884a420aeb4f2" title="Return the given pointer&#39;s ralloc context." alt="" coords="328,5,424,32"/><area shape="rect" id="node9" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="334,107,418,133"/><area shape="rect" id="node14" href="ralloc_8c.html#ab9a56787f0f0d1421c708a57383eae25" title="resize" alt="" coords="347,56,405,83"/><area shape="rect" id="node7" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="473,56,559,83"/><area shape="rect" id="node11" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="477,107,555,133"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3a1adf0ae73bf982e8aceff21b47959c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* reralloc_size </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a piece of ralloc-managed memory, preserving data. </p>
<p>Similar to <code>realloc</code>. Unlike C89, passing 0 for <code>size</code> does not free the memory. Instead, it resizes it to a 0-byte ralloc context, just like calling ralloc_size(ctx, 0). This is different from talloc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context to use for new allocation. If <code>ptr</code> != NULL, it must be the same as ralloc_parent(<code>ptr</code>). </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the memory to be resized. May be NULL. </td></tr>
    <tr><td class="paramname">size</td><td>The amount of memory to allocate, in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ralloc_8c.html#a9f820b482c39fab77bf884a420aeb4f2">ralloc_parent()</a>, <a class="el" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3">ralloc_size()</a>, and <a class="el" href="ralloc_8c.html#ab9a56787f0f0d1421c708a57383eae25">resize()</a>.</p>

<p>Referenced by <a class="el" href="ralloc_8h.html#af37fae09221c71687f0cc2295d6b163f">reralloc_array_size()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a3a1adf0ae73bf982e8aceff21b47959c_cgraph.png" border="0" usemap="#ralloc_8h_a3a1adf0ae73bf982e8aceff21b47959c_cgraph" alt=""/></div>
<map name="ralloc_8h_a3a1adf0ae73bf982e8aceff21b47959c_cgraph" id="ralloc_8h_a3a1adf0ae73bf982e8aceff21b47959c_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a9f820b482c39fab77bf884a420aeb4f2" title="Return the given pointer&#39;s ralloc context." alt="" coords="149,5,245,32"/><area shape="rect" id="node7" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="155,107,239,133"/><area shape="rect" id="node12" href="ralloc_8c.html#ab9a56787f0f0d1421c708a57383eae25" title="resize" alt="" coords="169,56,226,83"/><area shape="rect" id="node5" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="294,56,381,83"/><area shape="rect" id="node9" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="299,107,376,133"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a12c3f10245853c0bde6883e5365e4012"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rzalloc_array_size </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a zero-initialized array chained off the given context. </p>
<p>Similar to <code>calloc</code>.</p>
<p>More than a convenience function, this also checks for integer overflow when multiplying <code>size</code> and <code>count</code>. This is necessary for security. </p>

<p>References <a class="el" href="ralloc_8c.html#a04d6d49f08bc3721b2c5dd1faac23a1c">rzalloc_size()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a12c3f10245853c0bde6883e5365e4012_cgraph.png" border="0" usemap="#ralloc_8h_a12c3f10245853c0bde6883e5365e4012_cgraph" alt=""/></div>
<map name="ralloc_8h_a12c3f10245853c0bde6883e5365e4012_cgraph" id="ralloc_8h_a12c3f10245853c0bde6883e5365e4012_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a04d6d49f08bc3721b2c5dd1faac23a1c" title="Allocate zero&#45;initialized memory chained off of the given context." alt="" coords="181,31,272,57"/><area shape="rect" id="node5" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="321,31,405,57"/><area shape="rect" id="node7" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="459,5,536,32"/><area shape="rect" id="node9" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="454,56,541,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a04d6d49f08bc3721b2c5dd1faac23a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rzalloc_size </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate zero-initialized memory chained off of the given context. </p>
<p>This is similar to <code>calloc</code> with a size of 1. </p>

<p>References <a class="el" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3">ralloc_size()</a>.</p>

<p>Referenced by <a class="el" href="classast__node.html#a650b8159c2bae5f234ab8bcb794f8a48">ast_node::operator new()</a>, <a class="el" href="structast__type__qualifier.html#acc097699feb9ff759389d107c4238ce7">ast_type_qualifier::operator new()</a>, and <a class="el" href="ralloc_8h.html#a12c3f10245853c0bde6883e5365e4012">rzalloc_array_size()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="ralloc_8h_a04d6d49f08bc3721b2c5dd1faac23a1c_cgraph.png" border="0" usemap="#ralloc_8h_a04d6d49f08bc3721b2c5dd1faac23a1c_cgraph" alt=""/></div>
<map name="ralloc_8h_a04d6d49f08bc3721b2c5dd1faac23a1c_cgraph" id="ralloc_8h_a04d6d49f08bc3721b2c5dd1faac23a1c_cgraph">
<area shape="rect" id="node3" href="ralloc_8c.html#a03d668aa9fce8d82182c2bfbd3f2a4e3" title="Allocate memory chained off of the given context." alt="" coords="145,31,229,57"/><area shape="rect" id="node5" href="ralloc_8c.html#a903391903c44abede7014caadd9c0c43" title="add_child" alt="" coords="283,5,360,32"/><area shape="rect" id="node7" href="ralloc_8c.html#a0fc43c6a4cfbe7313285d0fd1d265e9c" title="get_header" alt="" coords="278,56,365,83"/></map>
</div>
</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
